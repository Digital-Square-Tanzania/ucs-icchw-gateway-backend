import dotenv from "dotenv";
import openmrsApiClient from "../../../utils/openmrs-api-client.js";
import RecoveryRepository from "./recovery-repository.js";
import CustomError from "../../../utils/custom-error.js";
import TeamMemberService from "../team-member/openmrs-team-member-service.js";
import postgresClient from "../../../utils/postgres-client.js";
import prisma from "../../../config/prisma.js";
import pLimit from "p-limit";

dotenv.config();

class RecoveryService {
  // Add records from UCS Master file into OpenMRS
  static async addPeopleInOpenmrs() {
    console.log("🔄 Adding people in OpenMRS...");
    let newPerson = null;
    let totalAdded = 0;
    let totalFailed = 0;
    let failedRecords = [];
    let successRecords = [];
    try {
      // Get people from our local database ucs_master table
      const recoveredAccounts = await RecoveryRepository.getAllRecoveredAccounts();
      if (!recoveredAccounts || recoveredAccounts.length === 0) {
        console.log("No people found in the local database.");
        throw new CustomError("No people found in the local database.", 404);
      }
      // Loop through each person and add them to OpenMRS
      for (const account of recoveredAccounts) {
        const personObject = {};
        personObject.names = [];
        personObject.names.push({
          givenName: account.firstName,
          middleName: account.middleName,
          familyName: account.familyName,
          preferred: true,
          prefix: account.gender.toLowerCase() === "male" ? "Mr" : "Ms",
        });

        personObject.birthdate = "1950-01-01";

        personObject.gender = account.gender.toLowerCase() === "male" ? "M" : "F";

        // Create the person in OpenMRS
        newPerson = await openmrsApiClient.post("person", personObject);

        if (!newPerson.uuid) {
          totalFailed++;
          failedRecords.push({ personId: account.id });
          console.error("Error creating OpenMRS person:", JSON.stringify(newPerson.response.data.error.message, null, 2));
          continue;
        }

        // Get the newly created person id and uuid
        const newPersonWithId = await openmrsApiClient.get(`person/${newPerson.uuid}?v=custom:(id,uuid)`);

        newPerson = newPersonWithId;

        // Update the local database with the OpenMRS id and uuid
        const updatePerson = await RecoveryRepository.updateOpenmrsPerson(account.id, {
          personId: newPerson.id,
          personUuid: newPerson.uuid,
        });

        if (!updatePerson.personUuid) {
          TeamMemberService.deletePerson(newPerson.id);
          console.error("Error updating OpenMRS person:", JSON.stringify(updatePerson.response.data.error.message));
          totalFailed++;
          failedRecords.push({ personId: account.id });
          continue;
        }

        // Create OpenMRS user
        let password = updatePerson.password;
        const hasLower = /[a-z]/.test(password);
        const hasUpper = /[A-Z]/.test(password);
        if (password.length < 8 || !hasLower || !hasUpper) {
          password += "1Ucs";
        }
        const userObject = {
          username: updatePerson.username,
          password: password,
          roles: [
            {
              uuid: process.env.UCS_PROD_PROVIDER_ROLE_UUID,
            },
          ],
          person: {
            uuid: updatePerson.personUuid,
          },
          systemId: updatePerson.username,
        };
        let newUser = null;
        newUser = await openmrsApiClient.post("user", userObject);
        if (!newUser.uuid) {
          TeamMemberService.deletePerson(newPerson.id);
          totalFailed++;
          failedRecords.push({ personId: account.id });
          console.error("Error creating OpenMRS user: " + JSON.stringify(newUser.response.data.error.message));
          throw new CustomError("Error creating OpenMRS user: ", 500);
        }

        // Get the newly created user id and uuid
        const newUserWithId = await openmrsApiClient.get(`user/${newUser.uuid}?v=custom:(id,uuid)`);
        newUser = newUserWithId;

        // Update the local database with the OpenMRS user id and uuid
        const updateUser = await RecoveryRepository.updateOpenmrsPersonById(updatePerson.id, {
          userId: newUser.id,
          userUuid: newUser.uuid,
        });
        if (updateUser.error) {
          totalFailed++;
          failedRecords.push({ personId: account.id });
          TeamMemberService.deletePerson(newPerson.id);
          console.error("Error updating OpenMRS user for person:", updatePerson.personUuid);
          continue;
        }

        // Fetch location UUIDs by username/identifier from OpenSRP team_member table
        let opensrpData;
        try {
          // Check if the username exists in the OpenSRP team_member table
          opensrpData = await postgresClient.query(
            "SELECT DISTINCT tm.*, em.team_id AS team_uuid FROM public.team_members tm JOIN core.event_metadata em ON tm.identifier = em.provider_id WHERE em.team_id IS NOT NULL AND tm.identifier =$1",
            [updatePerson.username]
          );
        } catch (error) {
          console.error("Error fetching location UUID:", error.message);
          TeamMemberService.deletePerson(updatePerson.personId);
          totalFailed++;
          failedRecords.push({ personId: account.id });
          continue;
        }

        if (!opensrpData || !opensrpData[0] || !opensrpData[0].location_uuid) {
          console.error("Team member data not found in OpenSRP events.");
          await TeamMemberService.deletePerson(updateUser.personId);
          totalFailed++;
          failedRecords.push({ personId: newPerson.id });
          await RecoveryRepository.updateOpenmrsPersonById(account.id, {
            errorLog: "Team member data not found in OpenSRP events.",
          });
          continue;
        }

        await RecoveryRepository.updateOpenmrsPersonById(updateUser.id, {
          locationUuid: opensrpData[0].location_uuid,
          locationName: opensrpData[0].location_name,
          teamName: opensrpData[0].team_name,
          teamUuid: opensrpData[0].team_uuid,
        });

        // Get Team details form OpenMRS, if no team, create one
        let openmrsTeam;
        let openmrsTeamWithId;
        try {
          let existingOpenmrsTeamWithId = await openmrsApiClient.get(`team/team/${opensrpData[0].team_uuid}?v=custom:(id,uuid,teamName,location:(id,uuid,name))`);

          // If the team does not exist, create a new one
          if (!existingOpenmrsTeamWithId || !existingOpenmrsTeamWithId.uuid) {
            const teamObject = {
              teamName: opensrpData[0].team_name,
              location: opensrpData[0].location_uuid,
              uuid: opensrpData[0].team_uuid,
              teamIdentifier: opensrpData[0].team_name.replace(/-/g, "").replace(/\s+/g, "").toLowerCase(),
            };
            console.log("Creating new OpenMRS team...");
            const newOpenmrsTeamWithId = await openmrsApiClient.post("team/team", teamObject);
            console.log("New OpenMRS team created", JSON.stringify(teamObject.uuid));
            if (!newOpenmrsTeamWithId || !newOpenmrsTeamWithId.uuid) {
              console.error("Error creating OpenMRS team:", JSON.stringify(newOpenmrsTeamWithId.response.data.error.message));
              await TeamMemberService.deletePerson(updateUser.personId);
              totalFailed++;
              failedRecords.push({ personId: newPerson.id });
              continue;
            }
            openmrsTeamWithId = newOpenmrsTeamWithId;
          }
          openmrsTeamWithId = existingOpenmrsTeamWithId;
        } catch (err) {
          console.error("Error fetching OpenMRS team:", err.message);
          await TeamMemberService.deletePerson(updateUser.personId);
          totalFailed++;
          failedRecords.push({ personId: newPerson.id });
          await RecoveryRepository.updateOpenmrsPersonById(account.id, {
            errorLog: "Error fetching OpenMRS team: " + err.message,
          });
          continue;
        }

        if (!openmrsTeamWithId || !openmrsTeamWithId.location || !openmrsTeamWithId.location.uuid) {
          console.error("OpenMRS team missing location info.");
          await TeamMemberService.deletePerson(updateUser.personId);
          totalFailed++;
          failedRecords.push({ personId: newPerson.id });
          await RecoveryRepository.updateOpenmrsPersonById(account.id, {
            errorLog: "OpenMRS team missing location info.",
          });
          continue;
        }

        openmrsTeam = openmrsTeamWithId;

        // Create a new team member in OpenMRS using collected details
        const teamMemberObject = {
          identifier: updateUser.username,
          locations: [
            {
              uuid: openmrsTeam.location.uuid,
            },
          ],
          joinDate: new Date().toISOString().split("T")[0],
          team: {
            uuid: openmrsTeam.uuid,
          },
          teamRole: {
            uuid: process.env.UCS_PROVIDER_TEAM_ROLE_UUID,
          },
          person: {
            uuid: updateUser.personUuid,
          },
          isDataProvider: "false",
        };

        let newTeamMember = await openmrsApiClient.post("team/teammember", teamMemberObject);
        if (!newTeamMember.uuid) {
          TeamMemberService.deletePerson(updateUser.personId);
          totalFailed++;
          failedRecords.push({ personId: newPerson.id });
          console.error("Error creating OpenMRS team member:", JSON.stringify(newTeamMember.response.data.error.message));
          continue;
        }

        // Get the newly created team member id and uuid
        const newTeamMemberWithId = await openmrsApiClient.get(`team/teammember/${newTeamMember.uuid}?v=custom:(id,uuid)`);
        newTeamMember = newTeamMemberWithId;

        // Update the local database with the OpenMRS team member id and uuid
        const updateTeamMember = await RecoveryRepository.updateOpenmrsPersonById(updateUser.id, {
          memberId: newTeamMember.id,
          memberUuid: newTeamMember.uuid,
          memberIdentifier: updateUser.username,
          teamRoleId: 1,
          locationId: openmrsTeam.location.id,
          teamRole: "UCS Provider",
          teamId: openmrsTeam.id,
        });
        if (!updateTeamMember) {
          TeamMemberService.deletePerson(updateUser.personId);
          totalFailed++;
          failedRecords.push({ personId: account.id });
          console.error("Error updating OpenMRS team member for person:", updateUser.personUuid);
          continue;
        }
        console.log("Successfully recovered OpenMRS team member:", updateTeamMember.memberUuid);
        totalAdded++;
        successRecords.push({ personId: account.id });
      }

      // Log the results and return the response with success and failure counts
      console.log(`✅ ${totalAdded} People recovered successfully in OpenMRS.`);
      var response = {
        totalAdded: totalAdded,
        totalFailed: totalFailed,
        successRecords: successRecords,
        failedRecords: failedRecords,
      };
      return response;
    } catch (error) {
      console.error("Error in addPeopleInOpenmrs:", error);
      throw new CustomError("Error adding people in OpenMRS: " + error.message, 500);
    }
  }

  static async checkAvailableTeamsInOpenmrs() {
    console.log("🔄 Checking available teams in OpenMRS...");
    try {
      const response = await openmrsApiClient.get("team/team");
      const openmrsTeams = response.results || [];

      if (openmrsTeams.length === 0) {
        console.log("No teams found in OpenMRS.");
        throw new CustomError("No teams found in OpenMRS.", 404);
      }

      const ucsMasterPeople = await RecoveryRepository.getAllUcsMasterPeople();
      if (!ucsMasterPeople || ucsMasterPeople.length === 0) {
        console.log("No records found in the local database.");
        throw new CustomError("No records found in the local database.", 404);
      }

      const ucsValidRecords = ucsMasterPeople.filter((team) => openmrsTeams.some((openmrsTeam) => openmrsTeam.name === team.teamName));

      if (ucsValidRecords.length === 0) {
        console.log("No matching teams found in OpenMRS.");
        throw new CustomError("No matching teams found in OpenMRS.", 404);
      }

      return ucsValidRecords;
    } catch (error) {
      console.error("Error in checkAvailableTeamsInOpenmrs:", error.stack);
      throw new CustomError("Error checking available teams in OpenMRS: " + error.message, 500);
    }
  }

  static async recoverMissingAccounts(doInsert = true) {
    try {
      // 1. Get team members from OpenSRP
      const teamMembers = await postgresClient.query(`
        SELECT identifier, location_uuid, team_name, name
        FROM public.team_members
        WHERE date_deleted IS NULL
      `);

      if (!Array.isArray(teamMembers) || teamMembers.length === 0) {
        return { inserted: 0, skipped: 0 };
      }

      // 2. Get all UCS master entries
      const ucsMaster = await prisma.ucsMaster.findMany({
        select: {
          username: true,
          firstName: true,
          middleName: true,
          familyName: true,
          dob: true,
          gender: true,
          password: true,
        },
      });

      // 3. Create fast lookup map
      const masterMap = new Map();
      ucsMaster.forEach((u) => {
        if (u.username) masterMap.set(u.username.trim().toLowerCase(), u);
      });

      // 4. Build recovered accounts
      const recoveredAccounts = teamMembers.map((member) => {
        const identifier = member.identifier?.trim().toLowerCase();
        const matched = masterMap.get(identifier);

        return {
          recoveredName: member.name || null,
          firstName: matched?.firstName || null,
          middleName: matched?.middleName || null,
          familyName: matched?.familyName || null,
          dob: matched?.dob || new Date("1950-01-01"),
          gender: matched?.gender || "Male",
          username: member.identifier,
          password: matched?.password || "R3c0v3r3d",
          memberIdentifier: member.identifier,
          teamId: null,
          teamUuid: null,
          teamName: member.team_name || null,
          teamRole: null,
          teamRoleId: null,
          personId: null,
          personUuid: null,
          userRole: "Provider",
          userId: null,
          userUuid: null,
          locationId: null,
          locationUuid: member.location_uuid || null,
          locationName: null,
          memberId: null,
          memberUuid: null,
          errorLog: null,
        };
      });

      if (!doInsert || recoveredAccounts.length === 0) {
        return {
          inserted: 0,
          skipped: 0,
        };
      }

      // 5. Insert via recovery repository
      const insertedCount = await RecoveryRepository.createRecoveredAccounts(recoveredAccounts);

      // 6. Log the results
      if (insertedCount > 0) {
        console.log(`✅ ${insertedCount} accounts recovered successfully.`);
      }
      if (insertedCount === 0) {
        console.log("No accounts were recovered.");
      }
      if (insertedCount < teamMembers.length) {
        console.log(`⚠️ ${teamMembers.length - insertedCount} accounts were skipped.`);
      }
      if (insertedCount > teamMembers.length) {
        console.log(`⚠️ ${insertedCount - teamMembers.length} accounts were inserted but not in the original list.`);
      }
      // 7. Return the result
      return {
        inserted: insertedCount,
        skipped: teamMembers.length - insertedCount,
      };
    } catch (error) {
      console.error("[ERROR] Recovery failed:", error.message);
      throw error;
    }
  }

  static async createMissingOpenmrsTeams() {
    try {
      // 1. Get all missing teams from recovered_records
      const missingTeams = await RecoveryRepository.getMissingOpenmrsTeams();
      if (!missingTeams || missingTeams.length === 0) {
        console.log("No missing teams found in the local database.");
        throw new CustomError("No missing teams found in the local database.", 404);
      }

      // 2. For each record, check if location exists in OpenMRS
      for (const team of missingTeams) {
        const locationUuid = team.locationUuid;
        const teamName = team.teamName;
        const teamUuid = team.teamUuid;

        // 3. Check if the location exists in OpenMRS
        const openmrsLocation = await openmrsApiClient.get(`location/${locationUuid}?v=custom:(id,uuid,name)`);
        if (!openmrsLocation || !openmrsLocation.uuid) {
          console.error("OpenMRS location not found:", locationUuid);
          continue;
        }

        // 4. Create a new team in OpenMRS
        const teamObject = {
          teamName: `${locationName}-Team`,
          location: openmrsLocation.uuid,
        };

        const newTeam = await openmrsApiClient.post("team/team", teamObject);
        if (!newTeam || !newTeam.uuid) {
          console.error("Error creating OpenMRS team:", JSON.stringify(newTeam.response.data.error.message));
          continue;
        }

        // 5. Update the local database with the OpenMRS team id and uuid
        await RecoveryRepository.updateOpenmrsPersonById(team.id, {
          teamId: newTeam.id,
          teamUuid: newTeam.uuid,
          errorLog: null,
        });
      }
    } catch (error) {}
  }
}

export default RecoveryService;
